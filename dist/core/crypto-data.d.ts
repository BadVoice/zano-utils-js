/// <reference types="node" />
/// <reference types="node" />
import BN from 'bn.js';
import { eddsa as EDDSA } from 'elliptic';
import RedBN from './interfaces';
export declare const ec: EDDSA;
export declare const A: {
    fromRed(): BN;
    redAdd(b: any): any;
    redIAdd(b: any): any;
    redSub(b: any): any;
    redISub(b: any): any;
    redShl(num: number): any;
    redMul(b: any): any;
    redIMul(b: any): any;
    redSqr(): any;
    redISqr(): any;
    redSqrt(): any;
    redInvm(): any;
    redNeg(): any;
    redPow(b: BN): any;
    copy(dest: BN): void;
    clone(): BN;
    toString(base?: number | "hex", length?: number): string;
    toNumber(): number;
    toJSON(): string;
    toArray(endian?: BN.Endianness, length?: number): number[];
    toArrayLike(ArrayType: BufferConstructor, endian?: BN.Endianness, length?: number): Buffer;
    toArrayLike(ArrayType: any[], endian?: BN.Endianness, length?: number): any[];
    toBuffer(endian?: BN.Endianness, length?: number): Buffer;
    bitLength(): number;
    zeroBits(): number;
    byteLength(): number;
    isNeg(): boolean;
    isEven(): boolean;
    isOdd(): boolean;
    isZero(): boolean;
    cmp(b: BN): 0 | 1 | -1;
    ucmp(b: BN): 0 | 1 | -1;
    cmpn(b: number): 0 | 1 | -1;
    lt(b: BN): boolean;
    ltn(b: number): boolean;
    lte(b: BN): boolean;
    lten(b: number): boolean;
    gt(b: BN): boolean;
    gtn(b: number): boolean;
    gte(b: BN): boolean;
    gten(b: number): boolean;
    eq(b: BN): boolean;
    eqn(b: number): boolean;
    toTwos(width: number): BN;
    fromTwos(width: number): BN;
    neg(): BN;
    ineg(): BN;
    abs(): BN;
    iabs(): BN;
    add(b: BN): BN;
    iadd(b: BN): BN;
    addn(b: number): BN;
    iaddn(b: number): BN;
    sub(b: BN): BN;
    isub(b: BN): BN;
    subn(b: number): BN;
    isubn(b: number): BN;
    mul(b: BN): BN;
    imul(b: BN): BN;
    muln(b: number): BN;
    imuln(b: number): BN;
    sqr(): BN;
    isqr(): BN;
    pow(b: BN): BN;
    div(b: BN): BN;
    divn(b: number): BN;
    idivn(b: number): BN;
    divmod(b: BN, mode?: "div" | "mod", positive?: boolean): {
        div: BN;
        mod: BN;
    };
    mod(b: BN): BN;
    umod(b: BN): BN;
    modn(b: number): number;
    modrn(b: number): number;
    divRound(b: BN): BN;
    or(b: BN): BN;
    ior(b: BN): BN;
    uor(b: BN): BN;
    iuor(b: BN): BN;
    and(b: BN): BN;
    iand(b: BN): BN;
    uand(b: BN): BN;
    iuand(b: BN): BN;
    andln(b: number): BN;
    xor(b: BN): BN;
    ixor(b: BN): BN;
    uxor(b: BN): BN;
    iuxor(b: BN): BN;
    setn(b: number, value: boolean | 0 | 1): BN;
    shln(b: number): BN;
    ishln(b: number): BN;
    ushln(b: number): BN;
    iushln(b: number): BN;
    shrn(b: number): BN;
    ishrn(b: number): BN;
    ushrn(b: number): BN;
    iushrn(b: number): BN;
    testn(b: number): boolean;
    maskn(b: number): BN;
    imaskn(b: number): BN;
    bincn(b: number): BN;
    notn(w: number): BN;
    inotn(w: number): BN;
    gcd(b: BN): BN;
    egcd(b: BN): {
        a: BN;
        b: BN;
        gcd: BN;
    };
    invm(b: BN): BN;
    toRed(reductionContext: BN.ReductionContext): any;
};
export declare const sqrtm1: RedBN;
export declare const fffb1: RedBN;
export declare const fffb2: RedBN;
export declare const fffb3: RedBN;
export declare const fffb4: RedBN;
